"""
NAME:
    plot_mact_with_newha.py

PURPOSE:

    depends on mainseq_corrections.py, 

INPUTS:
    FULL_PATH+'Main_Sequence/Berg2012_table.clean.txt'
    FULL_PATH+'Main_Sequence/Noeske07_fig1_z1.txt'
    FULL_PATH+'Main_Sequence/mainseq_corrections_tbl.txt'


OUTPUTS:
    FULL_PATH+'Plots/main_sequence/mainseq.pdf'
    if mainseq_fig4_only = True:
        FULL_PATH+'Plots/main_sequence/mainseq_allcorrs.pdf'
    FULL_PATH+'Plots/main_sequence/zdep_mainseq.pdf'
    FULL_PATH+'Plots/main_sequence/mainseq_sSFRs.pdf'
"""

import numpy as np, matplotlib.pyplot as plt
import plot_nbia_mainseq
# import scipy.optimize as optimize
import matplotlib as mpl
from astropy.io import ascii as asc, fits as pyfits
# from analysis.composite_errors import compute_onesig_pdf

# emission line wavelengths (air)
HA = 6562.80

FULL_PATH = '/Users/kaitlynshin/GoogleDrive/NASA_Summer2015/'
CUTOFF_SIGMA = 4.0
CUTOFF_MASS = 6.0

# newha_sfr_type = 'orig_sfr'
newha_sfr_type = 'met_dep_sfr'

def get_good_newha_ii(newhadata):
    '''
    returns indices of the newha data that have valid mass, sfrs, lha, and
    are not agns
    '''
    tempm = newhadata['LOGM']
    tempsfr = newhadata['LOGSFR_HA']
    templha = newhadata['L_HA']
    tempagn = newhadata['AGN']
    good_newha_ii = np.where((tempm > 0) & (tempsfr != 0) & (templha != 0)
        & (tempagn != 1))[0]

    return good_newha_ii


def get_newha_logsfrha(newhadata, newha_sfr_type):
    '''
    returns sfrs from the newha dataset depending on newha_sfr_type
    
    if the type is 'orig_sfr', then the sfr is returned directly from the tbl
    
    if the type is 'met_dep_sfr', then a metallicity-dependent sfr is derived
    from the luminosity and nii/ha ratios given in the table. this is to be
    consistent with the way the MACT dataset was analyzed
    '''
    if newha_sfr_type == 'orig_sfr':
        newha_logsfrha = newhadata['LOGSFR_HA']
    elif newha_sfr_type == 'met_dep_sfr':
        from mainseq_corrections import niiha_oh_determine

        l_ha = np.log10(newhadata['L_HA']) + 41 # ha luminosity
        nii_ha_best = newhadata['NII_HALPHA_BEST']
        nii6583_ha = nii_ha_best * 2.96/(1+2.96)

        # since this code estimates log(O/H)+12
        logOH = niiha_oh_determine(np.log10(nii6583_ha), 'PP04_N2') - 12
        y = logOH + 3.31 
        log_SFR_LHa = -41.34 + 0.39*y + 0.127*y**2 # metallicity-dependent

        newha_logsfrha = log_SFR_LHa + l_ha
    else:
        raise ValueError('invalid newha_sfr_type')

    return newha_logsfrha


def main():
    '''
    '''
    # reading in NewHa data
    newha = pyfits.open(FULL_PATH+'NewHa/NewHa.fits')
    newhadata_tmp = newha[1].data

    good_newha_ii = get_good_newha_ii(newhadata_tmp)
    newhadata = newhadata_tmp[good_newha_ii]

    newha_logm = newhadata['LOGM']
    newha_zspec = newhadata['Z_SPEC']
    newha_mzdata = np.vstack([newha_logm, newha_zspec]).T
    newha_logsfrha = get_newha_logsfrha(newhadata, newha_sfr_type)

    # reading in data generated by EBV_corrections.py
    corr_tbl = asc.read(FULL_PATH+'Main_Sequence/mainseq_corrections_tbl.txt',
        guess=False, Reader=asc.FixedWidthTwoLine)

    # defining a flux sigma and mass cutoff
    good_sig_iis = np.where((corr_tbl['flux_sigma'] >= CUTOFF_SIGMA) & 
        (corr_tbl['stlr_mass'] >= CUTOFF_MASS))[0]

    # getting/storing useful data
    zspec0 = np.array(corr_tbl['zspec0'])[good_sig_iis]
    stlr_mass = np.array(corr_tbl['stlr_mass'])[good_sig_iis]
    filts = np.array(corr_tbl['filt'])[good_sig_iis]
    sfr = np.array(corr_tbl['met_dep_sfr'])[good_sig_iis]
    dust_corr_factor = np.array(corr_tbl['dust_corr_factor'])[good_sig_iis]
    filt_corr_factor = np.array(corr_tbl['filt_corr_factor'])[good_sig_iis]
    nii_ha_corr_factor = np.array(corr_tbl['nii_ha_corr_factor'])[good_sig_iis]
    corr_sfrs = sfr+filt_corr_factor+nii_ha_corr_factor+dust_corr_factor
    zspec00 = plot_nbia_mainseq.approximated_zspec0(zspec0, filts)

    # defining useful data structs for plotting
    nh_ffarr = np.array(['NB7', 'NB816', 'NB921', 'NB973', 'NEWHA'])
    nh_llarr = np.array(['NB704,NB711', 'NB816', 'NB921', 'NB973', 'NEWHA'])
    z_arr = plot_nbia_mainseq.get_z_arr()
    nh_z_arr = np.append(z_arr, '%.2f'%np.mean(newha_zspec))
    nh_cwheel = [np.array(mpl.rcParams['axes.prop_cycle'])[x]['color']
        for x in range(5)]

    # combining datasets
    sfrs_with_newha  = np.concatenate((corr_sfrs, newha_logsfrha))
    mass_with_newha  = np.concatenate((stlr_mass, newha_logm))
    zspec_with_newha = np.concatenate((zspec0, newha_zspec))
    zspec_with_newha00 = np.concatenate((zspec00, newha_zspec))
    filts_with_newha = np.concatenate((filts,
        np.array(['NEWHA']*len(newha_logsfrha))))

    no_spectra  = np.where((zspec_with_newha <= 0) | (zspec_with_newha > 9))[0]
    yes_spectra = np.where((zspec_with_newha >= 0) & (zspec_with_newha < 9))[0]


    # plotting
    ssfrs_with_newha = sfrs_with_newha - mass_with_newha
    for ytype, ydata in zip(['SFR', 'sSFR'], 
        [sfrs_with_newha, ssfrs_with_newha]):
        print 'making redshift dependent plot (y-axis: '+ytype+')'

        f, ax = plt.subplots()
        plot_nbia_mainseq.make_redshift_graph(f, ax, nh_z_arr, ydata,
            mass_with_newha, zspec_with_newha00, filts_with_newha, no_spectra,
            yes_spectra, nh_cwheel, ffarr=nh_ffarr, llarr=nh_llarr, ytype=ytype)
        plt.savefig(FULL_PATH+'Plots/NewHa/zdep_mainseq_'+newha_sfr_type+
            '_'+ytype+'.pdf')
        plt.close()


    print 'making sSFR plot'
    f, axes = plt.subplots(1,2, sharey=True)
    plot_nbia_mainseq.make_ssfr_graph(f, axes, sfrs_with_newha,
        mass_with_newha, filts_with_newha, zspec_with_newha00, nh_cwheel,
        nh_z_arr, ffarr=nh_ffarr, llarr=nh_llarr)
    plt.savefig(FULL_PATH+'Plots/NewHa/mainseq_sSFRs_'+newha_sfr_type+'.pdf')
    plt.close()


    newha.close()


if __name__ == '__main__':
    main()